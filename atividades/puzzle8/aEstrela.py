import random
import itertools
import collections
import time

class No:
    """
    A class representing an Solver node
    - 'puzzle' is a Puzzle instance
    - 'pai' is the preceding node generated by the solver, if any
    - 'acao' is the acao taken to produce puzzle, if any
    """
    def __init__(self, puzzle, pai=None, acao=None):
        self.puzzle = puzzle
        self.pai = pai
        self.acao = acao
        if (self.pai != None):
            self.g = pai.g + 1
        else:
            self.g = 0

    @property
    def estado(self):
        """
        Return a hashable representation of self
        """
        return str(self)

    @property 
    def caminho(self):
        """
        Reconstruct a path from to the root 'pai'
        """
        node, p = self, []
        while node:
            p.append(node)
            node = node.pai
        yield from reversed(p)

    @property
    def resolvido(self):
        """ Wrapper to check if 'puzzle' is solved """
        return self.puzzle.solved

    @property
    def acoes(self):
        """ Wrapper for 'acoes' accessible atual current estado """
        return self.puzzle.acoes

    @property
    def h(self):
        return self.puzzle.heuristica

    @property
    def f(self):
        return self.h + self.g

    def __str__(self):
        return str(self.puzzle)

class Solucionador:
    """
    An '8-puzzle' solver
    - 'start' is a Puzzle instance
    """
    def __init__(self, start):
        self.start = start

    def resolver(self):
        """
        Perform breadth first search and return a path
        to the solution, if it exists
        """
        fila = collections.deque([No(self.start)])
        vistos = set()
        vistos.add(fila[0].estado)
        while fila:
            fila = collections.deque(sorted(list(fila), key=lambda no: no.f))
            no = fila.popleft()
            if no.resolvido:
                return no.caminho

            for mover, acao in no.acoes:
                filho = No(mover(), no, acao)

                if filho.estado not in vistos:
                    fila.appendleft(filho)
                    vistos.add(filho.estado)

class Puzzle:
    """
    A class representing an '8-puzzle'.
    - 'puzzle' should be a square list of lists with integer entries 0...width^2 - 1
    e.g. [[1,2,3],[4,0,6],[7,5,8]]
    """
    def __init__(self, puzzle):
        self.tamanho = len(puzzle[0])
        self.puzzle = puzzle

    @property
    def solved(self):
        """
        The puzzle is solved if the flattened puzzle's numbers are in
        increasing order from left to right and the '0' tile is in the
        last position on the puzzle
        """
        n = self.tamanho ** 2
        return str(self) == ''.join(map(str, range(1, n))) + '0'

    @property 
    def acoes(self):
        """
        Return a list of 'mover', 'acao' pairs. 'mover' can be called
        to return a new puzzle that results in sliding the '0' tile in
        the direction of 'acao'.
        """
        def criarMovimento(atual, novo):
            return lambda: self._mover(atual, novo)

        movimentos = []
        for i, j in itertools.product(range(self.tamanho), range(self.tamanho)):
            direcoes = {
                    'D':(i, j-1),
                    'E':(i, j+1),
                    'B':(i-1, j),
                    'C':(i+1, j)
                    }

            for acao, (x, y) in direcoes.items():
                if x >= 0 and y >= 0 and x < self.tamanho and y < self.tamanho and self.puzzle[x][y] == 0:
                    mover = criarMovimento((i,j), (x,y)), acao
                    movimentos.append(mover)
        return movimentos

    @property
    def heuristica(self):
        distancia = 0
        for i in range(3):
            for j in range(3):
                if self.puzzle[i][j] != 0:
                    x, y = divmod(self.puzzle[i][j]-1, 3)
                    distancia += abs(x - i) + abs(y - j)
        return distancia

    def embaralhar(self):
        """
        Return a new puzzle that has been shuffled with 1000 random movers
        """
        puzzle = self
        for _ in range(1000):
            puzzle = random.choice(puzzle.acoes)[0]()
        return puzzle

    def copiar(self):
        """
        Return a new puzzle with the same puzzle as 'self'
        """
        puzzle = []
        for row in self.puzzle:
            puzzle.append([x for x in row])
        return Puzzle(puzzle)

    def _mover(self, atual, novo):
        """
        Return a new puzzle where 'atual' and 'to' tiles have been swapped.
        NOTE: all movers should be 'acaos' that have been executed
        """
        copia = self.copiar()
        i, j = atual
        x, y = novo
        copia.puzzle[i][j], copia.puzzle[x][y] = copia.puzzle[x][y], copia.puzzle[i][j]
        return copia

    def imprimePuzzle(self):
        for row in self.puzzle:
            print(row)
        print()

    def __str__(self):
        return ''.join(map(str, self))

    def __iter__(self):
        for row in self.puzzle:
            yield from row


# example of use     
puzzle = [[1,2,3],[4,5,0],[6,7,8]]
puzzle = Puzzle(puzzle)
puzzle = puzzle.embaralhar()
s = Solucionador(puzzle)
inicio = time.time()
p = s.resolver()
fim = time.time()

passos = 0

for no in p:
    print(no.acao)
    no.puzzle.imprimePuzzle()
    passos += 1

print("Numero de passos: ", passos)
print("Total amount of time in search: " + str(fim - inicio) + " second(s)")